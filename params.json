{"name":"Nullproof","tagline":"A Java null arguments proofed object constructor by Guice AOP or AspectJ","body":"nullproof\r\n=============\r\nA Java null arguments proofed object constructor by Guice AOP or AspectJ\r\n\r\n##Purpose\r\nIf you have a Class which conatains 20 methods and each method takes 2 arguments,\r\nyou probably need to repeat following line of code 40 times!!\r\n```java\r\nif(arg == null)\r\n    throw new NullPointerException(\"Your error message\");\r\n```\r\nWith NullProof, you don't need to do it anymore.\r\n\r\n#Maven Repo\r\n```xml\r\n<dependency>\r\n    <groupId>com.github.wnameless</groupId>\r\n    <artifactId>nullproof</artifactId>\r\n    <version>0.4.2</version>\r\n</dependency>\r\n```\r\nAspectJ is supported since v0.2.0.\r\n\r\n#Quick Start\r\n###With AspectJ\r\n```java\r\n@RejectNull\r\npublic class Foo { ... }\r\n```\r\n\r\n###With Guice\r\nClass with 0-argument constructor\r\n```java\r\nFoo foo = NullProof.of(Foo.class);\r\nfoo.bar(null); // throws NullPointerException\r\n```\r\n\r\nClass with single implementation arguments constructor\r\n```java\r\nFoo foo = NullProof.of(Foo.class, 123, \"abc\");\r\nfoo.bar(null); // throws NullPointerException\r\n```\r\n\r\nClass with generic and upcasting arguments constructor\r\n```java\r\nFoo foo = new NullProof.Constructor<Foo>(Foo.class)\r\n        .forType(new TypeLiteral<Map<String, Integer>>() {})\r\n        .addArgument(new HashMap<String, Integer>()).create();\r\nfoo.bar(null); // throws NullPointerException\r\n```\r\n\r\n#Feature\r\nBoth runtime Guice AOP and AspectJ are supported.\r\n\r\nThe first difference shows in following codes:\r\n```java\r\nFoo foo1 = NullProof.of(Foo.class); // Works even there is no @RejectNull found on the class.\r\nFoo foo2 = new Foo(); // Works only if there is @RejectNull annotated on the class (and of course you have to compile it with AspectJ).\r\n```\r\nThe second difference is that AspectJ blocks null arguments of constructors(since v0.3.0),\r\nbut Guice simply not allows null arguments to bind with constructors.\r\n\r\nAnnotation-Driven configuration:\r\n```java\r\n@RejectNull // On Type or Method.\r\n@Argument   // Can only used within RejectNull\r\n@AcceptNull // On Type or Method.\r\n```\r\n\r\n@RejectNull can be used to set up the default behavior of NullProof.\r\n```java\r\n@RejectNull({\r\n    @Argument(type = String.class, message = \"Oop!\"),\r\n    @Argument(type = Integer.class, ignore = true) })\r\n```\r\n\r\n@AcceptNull can be used to ignore certain methods.\r\n```java\r\n@AcceptNull({ \"bar1\", \"bar2\" }) // Works on Type\r\n@AcceptNull // Works on Method\r\n```\r\n\r\nDescriptive default error message, the original line number is kept:\r\n```java\r\njava.lang.NullPointerException: Parameter<String> is not nullable\r\n\tat com.github.wnameless.nullproof.Foo.bar(Foo.java:16)\r\n        ...\r\n```\r\n\r\n#Best Practice with Guice\r\nUsing NullProof with static factory pattern to ensure every instance is prevented from null arguments.\r\n```java\r\npublic Foo { // Non-final class is required\r\n    public static Foo create() {\r\n      return NullProof.of(Foo.class);\r\n    }\r\n\r\n    Foo () {} // At least 1 package-private(non-private) constuctor is required to let Guice do the AOP\r\n    ...\r\n}\r\n```\r\n\r\n#Tip for AspectJ\r\nIf you are using aspectj-maven-plugin with Eclipse AJDT. Try to create a java file with following content in your project. It allows AJDT to help you indentify all the AspectJ advice in your source codes during development.\r\n```java\r\n@Aspect\r\npublic class NullProofAspect extends AbstractNullProofAspect {}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}